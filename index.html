<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wizard's Hand</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #282c34;
            color: #abb2bf;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding-top: 20px;
            user-select: none; /* Prevent text selection during clicks */
        }

        #game-container {
            background-color: #3a3f4b;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            width: 90%;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #ui-area, #round-info {
            display: flex;
            justify-content: space-around;
            background-color: #21252b;
            padding: 10px;
            border-radius: 5px;
            font-weight: bold;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        #round-info {
             justify-content: center;
             gap: 20px; /* Space between Trial and Score */
        }

        .info-item {
            text-align: center;
            min-width: 100px; /* Ensure items don't get too squished */
            padding: 5px 0;
        }

        .info-value {
            color: #61afef; /* Light blue */
            font-size: 1.2em;
        }

        #hand-area {
            min-height: 100px;
            display: flex;
            flex-wrap: wrap; /* Allow cards to wrap */
            justify-content: center;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background-color: #2c313a;
            border-radius: 5px;
            border: 1px solid #4f5666;
        }

        .card {
            border: 1px solid #abb2bf;
            padding: 10px 5px;
            min-width: 60px;
            height: 85px;
            text-align: center;
            border-radius: 5px;
            background-color: #f0f0f0;
            color: #21252b;
            cursor: pointer;
            transition: transform 0.1s ease-out, box-shadow 0.1s ease-out;
            position: relative; /* For absolute positioning of suit */
            font-size: 1.4em;
            font-weight: bold;
            display: flex;
            flex-direction: column;
            justify-content: space-between; /* Push rank and suit apart */
        }

        .card:hover {
            transform: translateY(-5px);
        }

        .card.selected {
            border: 2px solid #e5c07b; /* Gold */
            box-shadow: 0 0 8px #e5c07b;
            transform: translateY(-3px);
        }

        .card-rank {
             line-height: 1;
        }

        .card-suit {
            font-size: 1.2em;
             line-height: 1;
        }

        /* Suit Colors */
        .suit-ðŸ”¥ { color: #e06c75; /* Red */ }
        .suit-ðŸ’§ { color: #61afef; /* Blue */ }
        .suit-ðŸŒ³ { color: #98c379; /* Green */ }
        .suit-ðŸ’¨ { color: #c678dd; /* Purple */ }

        /* Rank Colors (Face Cards) */
        .rank-J, .rank-Q, .rank-K, .rank-A { font-weight: bold; }

        #action-area {
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        button {
            padding: 10px 20px;
            font-size: 1em;
            font-weight: bold;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            min-width: 150px;
        }

        button:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }

        #play-button {
            background-color: #98c379; /* Green */
            color: #21252b;
        }
        #play-button:hover:not(:disabled) { background-color: #a7d48a; }
        #play-button:disabled { background-color: #6a8b55; }


        #discard-button {
            background-color: #e06c75; /* Red */
            color: #21252b;
        }
        #discard-button:hover:not(:disabled) { background-color: #eb7f8a; }
        #discard-button:disabled { background-color: #a14d54; }


        #message-area {
            min-height: 40px;
            text-align: center;
            font-size: 1.1em;
            color: #e5c07b; /* Gold */
            background-color: #21252b;
            padding: 8px;
            border-radius: 5px;
        }

        #game-over-overlay, #game-won-overlay {
            display: none; /* Hidden by default */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 1000;
        }

        .overlay-content {
            background-color: #3a3f4b;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.7);
        }
         .overlay-content h2 {
             margin-bottom: 20px;
             color: #e06c75; /* Red for Game Over */
         }
         #game-won-overlay .overlay-content h2 {
             color: #98c379; /* Green for Win */
         }

        #new-game-button {
             background-color: #61afef; /* Blue */
             color: #21252b;
             margin-top: 20px;
         }
        #new-game-button:hover { background-color: #7ac0f7; }

    </style>
</head>
<body>
    <div id="game-container">
        <div id="round-info">
             <div class="info-item">Trial (Ante) <span id="round-display" class="info-value">1</span></div>
             <div class="info-item">Target Score (Blind) <div id="target-score-display" class="info-value">0</div></div>
        </div>

        <div id="ui-area">
            <div class="info-item">Score<div id="score-display" class="info-value">0</div></div>
            <div class="info-item">Hands Left<div id="hands-left-display" class="info-value">0</div></div>
            <div class="info-item">Discards Left<div id="discards-left-display" class="info-value">0</div></div>
            <div class="info-item">Mana<div id="mana-display" class="info-value">0</div></div> <!-- Placeholder for currency -->
        </div>

        <div id="message-area">Welcome to Wizard's Hand! Select cards to play.</div>

        <div id="hand-area">
            <!-- Cards will be generated here by JavaScript -->
        </div>

        <div id="action-area">
            <button id="play-button" disabled>Play Selected Hand</button>
            <button id="discard-button" disabled>Discard Selected</button>
        </div>

        <!-- Placeholder for future Jokers/Familiars -->
        <!-- <div id="familiar-area"><h4>Familiars</h4></div> -->
    </div>

    <div id="game-over-overlay">
         <div class="overlay-content">
             <h2>Trial Failed!</h2>
             <p>Your score was not high enough.</p>
             <p>You reached Trial <span id="final-round-lost">1</span>.</p>
             <button id="new-game-button-lost">Cast Again (New Game)</button>
         </div>
    </div>

    <div id="game-won-overlay">
         <div class="overlay-content">
             <h2>Supreme Archmage!</h2>
             <p>You conquered all the Trials!</p>
             <button id="new-game-button-won">Cast Again (New Game)</button>
         </div>
    </div>


    <script>
        const SUITS = ['ðŸ”¥', 'ðŸ’§', 'ðŸŒ³', 'ðŸ’¨']; // Fire, Water, Earth, Air
        const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'];
        const RANK_VALUES = { '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14 };

        // Simplified Hand Scoring (Base Chips * Base Mult)
        // In real Balatro, these level up and are affected by Jokers
        const HAND_DEFINITIONS = {
            'High Card':      { chips: 5,  mult: 1 },
            'Pair':           { chips: 10, mult: 2 },
            'Two Pair':       { chips: 20, mult: 2 },
            'Three of a Kind':{ chips: 30, mult: 3 },
            'Straight':       { chips: 30, mult: 4 },
            'Flush':          { chips: 35, mult: 4 },
            'Full House':     { chips: 40, mult: 4 },
            'Four of a Kind': { chips: 60, mult: 7 },
            'Straight Flush': { chips: 100, mult: 8 },
            // 'Royal Flush': { chips: 120, mult: 10 }, // Often just a high Straight Flush
        };

        const MAX_HAND_SIZE = 8;
        const CARDS_TO_PLAY_MAX = 5;
        const INITIAL_HANDS = 4;
        const INITIAL_DISCARDS = 3;
        const WINNING_ANTE = 8; // Beat Ante 8 to win

        let deck = [];
        let hand = [];
        let discardPile = [];
        let selectedCardIds = [];

        let currentScore = 0;
        let currentRound = 1; // Ante
        let targetScore = 0; // Blind
        let handsLeft = INITIAL_HANDS;
        let discardsLeft = INITIAL_DISCARDS;
        let mana = 0; // Currency placeholder
        let gameOver = false;
        let gameWon = false;

        // --- DOM Elements ---
        const handArea = document.getElementById('hand-area');
        const scoreDisplay = document.getElementById('score-display');
        const targetScoreDisplay = document.getElementById('target-score-display');
        const roundDisplay = document.getElementById('round-display');
        const handsLeftDisplay = document.getElementById('hands-left-display');
        const discardsLeftDisplay = document.getElementById('discards-left-display');
        const manaDisplay = document.getElementById('mana-display');
        const messageArea = document.getElementById('message-area');
        const playButton = document.getElementById('play-button');
        const discardButton = document.getElementById('discard-button');
        const gameOverOverlay = document.getElementById('game-over-overlay');
        const gameWonOverlay = document.getElementById('game-won-overlay');
        const newGameButtonLost = document.getElementById('new-game-button-lost');
        const newGameButtonWon = document.getElementById('new-game-button-won');
        const finalRoundLostDisplay = document.getElementById('final-round-lost');


        // --- Core Game Logic ---

        function createDeck() {
            deck = [];
            let idCounter = 0;
            for (const suit of SUITS) {
                for (const rank of RANKS) {
                    deck.push({ id: idCounter++, rank: rank, suit: suit });
                }
            }
        }

        function shuffleDeck(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]]; // Swap elements
            }
        }

        function drawCards(count) {
            const drawnCards = [];
            for (let i = 0; i < count; i++) {
                if (deck.length === 0) {
                    if (discardPile.length === 0) {
                        console.warn("No cards left in deck or discard pile!");
                        break; // Cannot draw more cards
                    }
                    // Reshuffle discard pile into deck
                    deck = [...discardPile];
                    discardPile = [];
                    shuffleDeck(deck);
                    setMessage("Reshuffling discard pile...");
                }
                 if (deck.length > 0) { // Check again after potential reshuffle
                    drawnCards.push(deck.pop());
                 } else {
                     break; // Stop if still no cards
                 }
            }
            hand = [...hand, ...drawnCards];
        }

        function dealInitialHand() {
            hand = [];
            discardPile = [];
            drawCards(MAX_HAND_SIZE);
        }

        function renderHand() {
            handArea.innerHTML = ''; // Clear existing cards
            hand.sort((a,b) => RANK_VALUES[a.rank] - RANK_VALUES[b.rank]); // Sort hand for display
            hand.forEach(card => {
                const cardElement = document.createElement('div');
                cardElement.classList.add('card');
                cardElement.dataset.cardId = card.id;

                const rankElement = document.createElement('div');
                rankElement.classList.add('card-rank', `rank-${card.rank}`);
                rankElement.textContent = card.rank;

                const suitElement = document.createElement('div');
                suitElement.classList.add('card-suit', `suit-${card.suit}`);
                suitElement.textContent = card.suit;

                // Add suit color class to the main card element for potential styling override
                 cardElement.classList.add(`suit-${card.suit}`);

                cardElement.appendChild(rankElement);
                cardElement.appendChild(suitElement);


                if (selectedCardIds.includes(card.id)) {
                    cardElement.classList.add('selected');
                }

                cardElement.addEventListener('click', () => selectCard(card.id));
                handArea.appendChild(cardElement);
            });
            updateButtonStates();
        }

        function renderUI() {
            scoreDisplay.textContent = currentScore;
            targetScoreDisplay.textContent = targetScore;
            roundDisplay.textContent = currentRound;
            handsLeftDisplay.textContent = handsLeft;
            discardsLeftDisplay.textContent = discardsLeft;
            manaDisplay.textContent = mana; // Update mana display

            if (gameOver) {
                finalRoundLostDisplay.textContent = currentRound;
                gameOverOverlay.style.display = 'flex';
            } else {
                gameOverOverlay.style.display = 'none';
            }

            if (gameWon) {
                 gameWonOverlay.style.display = 'flex';
            } else {
                gameWonOverlay.style.display = 'none';
            }
        }

        function setMessage(message) {
            messageArea.textContent = message;
        }

        function selectCard(cardId) {
            if (gameOver || gameWon) return;

            const index = selectedCardIds.indexOf(cardId);
            if (index > -1) {
                selectedCardIds.splice(index, 1); // Deselect
            } else {
                 if (selectedCardIds.length < CARDS_TO_PLAY_MAX) {
                      selectedCardIds.push(cardId); // Select if less than max allowed
                 } else {
                     setMessage(`You can only select up to ${CARDS_TO_PLAY_MAX} cards to play.`);
                 }
            }
            renderHand(); // Re-render to show selection change
        }

        function updateButtonStates() {
            const selectionCount = selectedCardIds.length;
            playButton.disabled = gameOver || gameWon || selectionCount === 0 || handsLeft <= 0;
            discardButton.disabled = gameOver || gameWon || selectionCount === 0 || discardsLeft <= 0;
        }


        function playSelectedHand() {
            if (playButton.disabled) return;

            const selectedCards = hand.filter(card => selectedCardIds.includes(card.id));
            if (selectedCards.length === 0) {
                setMessage("Select cards to play a hand.");
                return;
            }
             if (selectedCards.length > CARDS_TO_PLAY_MAX) {
                 setMessage(`You cannot play more than ${CARDS_TO_PLAY_MAX} cards.`);
                 return; // Should be prevented by selectCard, but double check
             }

            const evaluation = evaluateHand(selectedCards);
            const scoreGained = evaluation.score;
            currentScore += scoreGained;
            handsLeft--;

             // Add played cards to discard pile
            discardPile.push(...selectedCards);

            // Remove played cards from hand
            hand = hand.filter(card => !selectedCardIds.includes(card.id));
            selectedCardIds = []; // Clear selection

            // Draw replacements
            const cardsToDraw = Math.min(selectedCards.length, MAX_HAND_SIZE - hand.length);
            drawCards(cardsToDraw);

            setMessage(`Played ${evaluation.handName}! Score: ${evaluation.chips} x ${evaluation.mult} = ${scoreGained}`);
            checkRoundEnd(); // Check if round ends after playing
            renderHand();
            renderUI();
        }

        function discardSelectedCards() {
             if (discardButton.disabled) return;

            const selectedCards = hand.filter(card => selectedCardIds.includes(card.id));
             if (selectedCards.length === 0) {
                setMessage("Select cards to discard.");
                return;
            }

            discardsLeft--;

            // Add discarded cards to discard pile
            discardPile.push(...selectedCards);

            // Remove discarded cards from hand
            hand = hand.filter(card => !selectedCardIds.includes(card.id));
            selectedCardIds = []; // Clear selection

            // Draw replacements
             const cardsToDraw = Math.min(selectedCards.length, MAX_HAND_SIZE - hand.length);
            drawCards(cardsToDraw);

            setMessage(`Discarded ${selectedCards.length} card(s).`);
            checkRoundEnd(); // Check if round ends after discarding (if out of hands/discards)
            renderHand();
            renderUI();
        }

        // --- Hand Evaluation Logic ---

        function evaluateHand(cards) {
            if (!cards || cards.length === 0) {
                return { handName: 'None', chips: 0, mult: 0, score: 0 };
            }

            const handInfo = checkPokerHand(cards);
            const definition = HAND_DEFINITIONS[handInfo.name] || HAND_DEFINITIONS['High Card'];

            // Apply any potential modifiers here (e.g., from Jokers/Familiars if implemented)
            let finalChips = definition.chips;
            let finalMult = definition.mult;

            // Example: Add chips based on specific ranks in the played hand (like Balatro's enhancements)
            cards.forEach(card => {
                 if (['A', 'K', 'Q', 'J'].includes(card.rank)) finalChips += 2; // Small bonus for face cards
                 else if (['T'].includes(card.rank)) finalChips += 1;
            });

            // Example: Small mult bonus for flushes or straights beyond base
            if (handInfo.name === 'Flush' && cards.length === 5) finalMult += 1;
            if (handInfo.name === 'Straight' && cards.length === 5) finalMult += 1;


            const score = finalChips * finalMult;
            return { handName: handInfo.name, chips: finalChips, mult: finalMult, score: score };
        }


        function checkPokerHand(cards) {
             // Sort cards by rank value for easier checking
            const sortedCards = [...cards].sort((a, b) => RANK_VALUES[a.rank] - RANK_VALUES[b.rank]);
            const ranks = sortedCards.map(c => c.rank);
            const suits = sortedCards.map(c => c.suit);
            const rankValues = sortedCards.map(c => RANK_VALUES[c.rank]);

            const rankCounts = {};
            ranks.forEach(rank => { rankCounts[rank] = (rankCounts[rank] || 0) + 1; });
            const counts = Object.values(rankCounts).sort((a, b) => b - a); // [4] or [3, 1] or [2, 2, 1] etc.

            const isFlush = new Set(suits).size === 1;
            // Check for standard straight
            let isStraight = rankValues.every((val, i, arr) => i === 0 || val === arr[i-1] + 1);
             // Check for A-2-3-4-5 low straight (Ace value is 14, need 2,3,4,5)
            if (!isStraight && rankValues.includes(14) && rankValues.includes(2) && rankValues.includes(3) && rankValues.includes(4) && rankValues.includes(5) && cards.length === 5) {
                 isStraight = true;
                 // Note: For scoring, you might treat Ace as 1 here, but keep RANK_VALUES consistent for sorting/general use
            }


             // Determine hand type based on cards *played* (can be 1 to 5)
             if (cards.length === 5) {
                if (isStraight && isFlush) return { name: 'Straight Flush' };
                if (counts[0] === 4) return { name: 'Four of a Kind' };
                if (counts[0] === 3 && counts[1] === 2) return { name: 'Full House' };
                if (isFlush) return { name: 'Flush' };
                if (isStraight) return { name: 'Straight' };
                if (counts[0] === 3) return { name: 'Three of a Kind' };
                if (counts[0] === 2 && counts[1] === 2) return { name: 'Two Pair' };
                if (counts[0] === 2) return { name: 'Pair' };
             } else if (cards.length === 4) {
                 if (counts[0] === 4) return { name: 'Four of a Kind' };
                 if (counts[0] === 3) return { name: 'Three of a Kind' };
                 if (counts[0] === 2 && counts[1] === 2) return { name: 'Two Pair' };
                 if (counts[0] === 2) return { name: 'Pair' };
                 // Could add 4-card flush/straight checks if desired
             } else if (cards.length === 3) {
                 if (counts[0] === 3) return { name: 'Three of a Kind' };
                 if (counts[0] === 2) return { name: 'Pair' };
                 // Could add 3-card flush/straight checks
             } else if (cards.length === 2) {
                 if (counts[0] === 2) return { name: 'Pair' };
             }
             // Default or single card
             return { name: 'High Card' }; // Or Pair if length was 2 and it was a pair
        }


        // --- Round and Game Flow ---

        function calculateRoundTarget(round) {
            // Simple scaling blind - adjust as needed for balance
            return Math.floor(100 * Math.pow(1.6, round - 1));
        }

        function startRound(roundNum) {
            currentRound = roundNum;
            targetScore = calculateRoundTarget(currentRound);
            currentScore = 0;
            handsLeft = INITIAL_HANDS;
            discardsLeft = INITIAL_DISCARDS;
            selectedCardIds = []; // Clear selection from previous round

            // Only deal a new hand if starting the very first round
            if (currentRound === 1) {
                 createDeck();
                 shuffleDeck(deck);
                 dealInitialHand();
            } else {
                 // Keep existing hand, maybe draw up to max if needed (optional)
                 const cardsToDraw = MAX_HAND_SIZE - hand.length;
                 if (cardsToDraw > 0) drawCards(cardsToDraw);
            }


            setMessage(`Starting Trial ${currentRound}. Beat ${targetScore} points.`);
            renderHand();
            renderUI();
        }

        function checkRoundEnd() {
            // Round ends if no hands left, OR if score meets target (early win for the round)
             if (currentScore >= targetScore) {
                const manaEarned = Math.floor((currentScore - targetScore) / 10) + (currentRound * 2); // Simple mana gain formula
                mana += manaEarned;
                setMessage(`Trial ${currentRound} Cleared! Gained ${manaEarned} Mana.`);
                // Delay starting next round slightly
                setTimeout(() => {
                    if (currentRound >= WINNING_ANTE) {
                         winGame();
                    } else {
                        startRound(currentRound + 1);
                    }
                }, 1500);
             } else if (handsLeft <= 0 && discardsLeft <= 0) { // Also check discards, must use one or the other
                 // If out of hands AND discards, and score is too low -> Game Over
                 if (currentScore < targetScore) {
                     loseGame();
                 }
                 // If score is high enough here, the earlier check already handled it.
                 // If somehow hands are 0 but score isn't enough, but discards ARE left, the player MUST discard.
             } else if (handsLeft <= 0 && currentScore < targetScore) {
                 setMessage("Out of hands! You must discard if possible.");
                 // Buttons will update to only allow discard if available
                 updateButtonStates();
             }
             // Otherwise, continue the round
        }


        function loseGame() {
            gameOver = true;
            setMessage(`Game Over! Failed to beat Trial ${currentRound}.`);
            renderUI(); // Show game over screen
        }

         function winGame() {
            gameWon = true;
            setMessage(`Congratulations! You beat all ${WINNING_ANTE} Trials!`);
            renderUI(); // Show game won screen
        }


        function resetGame() {
            gameOver = false;
            gameWon = false;
            deck = [];
            hand = [];
            discardPile = [];
            selectedCardIds = [];
            currentScore = 0;
            currentRound = 1;
            targetScore = 0;
            handsLeft = INITIAL_HANDS;
            discardsLeft = INITIAL_DISCARDS;
            mana = 0;

            gameOverOverlay.style.display = 'none';
            gameWonOverlay.style.display = 'none';

            initGame();
        }

        function initGame() {
            console.log("Initializing Wizard's Hand...");
            startRound(1); // Start the first round
        }

        // --- Event Listeners ---
        playButton.addEventListener('click', playSelectedHand);
        discardButton.addEventListener('click', discardSelectedCards);
        newGameButtonLost.addEventListener('click', resetGame);
        newGameButtonWon.addEventListener('click', resetGame);


        // --- Initial Game Start ---
        document.addEventListener('DOMContentLoaded', initGame);

    </script>
</body>
</html>